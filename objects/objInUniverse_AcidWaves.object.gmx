<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprInUniverse_SMB3Acid</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2</depth>
  <persistent>0</persistent>
  <parentName>prtAlwaysActive</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>shiftVisible = true;

depth = 1000020;

imgspeed = 1/12; //the default image_speed variable is set to 0 while switching sections

//todo: maybe pull collision checking from objWidget?
//manually adjusts the position of the waves, compared to other AcidWave objects.
flatMod = 0;
//how high the waves are
waveAmp = 80;
//how many columns of waves in one object
multip = 1;
//what sprite to use for the waves
sprIndex = sprite_index;

//array code, act and waveTimer isn't cc-able;
for (m = 0; m &lt;= multip; m++)
{
    act[m] = 0;
    waveTimer[m] = 0;
    imgIndex[m] = 0;
    // how fast the line of the wave moves
    addAct[m] = 1;
    // how much time influences the waves. lower is slower
    timeMod[m] = 0.02;
    // how much position influences the waves. 
    // lower is wider, 0 is flat. graphics may break down if set above ~0.8
    distMod[m] = 0.8;
    // how far is each wave from the top wave in pixels;
    yOffset[m] = 12;
}

//the color of the inside of the wave, past the surface sprites
fillCol = make_color_rgb(0, 186, 0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//moves when unpaused, or when out of section
if (!global.frozen || instance_exists(objSectionSwitcher))
{
    //image_index += imgspeed;
    for (k = 0; k &lt; multip; k++)
    {
        act[k]+= addAct[k];
        waveTimer[k]+= timeMod[k];
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var vatLength = image_xscale * 16;
var screenRightEnd = view_xview + view_wview + 16;
var hiPoint = 0;

for (var d = 0; d &lt; multip; d++)
{
for (var b = 0/*max(0, round(view_xview - x))*/; b &lt; vatLength; b++;)
{
    var xpos = x + b; //determine x position of column
    
    //stop drawing when we're past the screen
    if (xpos &gt; screenRightEnd)
        break;
    
    var u;
    u[d] = sin(waveTimer[d] + ((b / 16) * distMod[d]) + flatMod);   //determine y position of column
    u[d] = (u[d] - 1) * (waveAmp / 2);
    
    if (u[d] &lt; hiPoint)
        hiPoint = u[d];
    if (image_yscale &gt; 0)
    {//surface facing up
        //filler
        /*if (b mod 16 == 15)
        {
            draw_rectangle_color(xpos + 1, y + 48, xpos - 16, floor(y + hiPoint + 47), 
                fillCol, fillCol, fillCol, fillCol, false);
            var hiPoint = 0;
        }*/
        //bubbly surface
        /*for (var i = 0; i &lt; multip; i++)
        {*/
            var left = modf((b mod sprite_get_width(sprIndex)) - act[d], 
            sprite_get_width(sprIndex) - 1);
            draw_sprite_part(sprIndex, imgIndex[d], left, 0,
                1, sprite_get_height(sprIndex), view_xview + b, 
                round(y + (yOffset[d] * d) + u[d]));
        //}
    }
    /*else    
    {//surface facing down
        //filler
        if (b mod 16 == 15)
        {
            draw_rectangle_color(xpos + 1, y - 32, xpos - 16, floor(y - (hiPoint + 31)), 
                fillCol, fillCol, fillCol, fillCol, false);
            var hiPoint = 0;
        }
        //bubbly surface
        draw_sprite_part(sprInUniverse_SMB3AcidReverse, image_index, b mod 16, 0,
            1, 32, xpos, round(y - u) - 32);
    }*/
}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
